---
phase: 04-guardrails-export
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/components/graph/GraphCanvas.tsx
  - apps/web/components/graph/ExportFAB.tsx
  - apps/web/app/app/page.tsx
  - apps/web/proxy.ts
  - apps/web/package.json
autonomous: true
requirements:
  - EXP-01
  - EXP-02
  - RATE-02

must_haves:
  truths:
    - "User sees Export JSON and Export PNG floating action buttons when a graph is displayed"
    - "Clicking Export JSON downloads a cleaned JSON file with nodes and edges"
    - "Clicking Export PNG downloads a full-graph PNG with app background color"
    - "Export buttons are not rendered when no graph exists"
    - "Filenames are auto-generated from graph content with date"
    - "IPs exceeding 60 requests/minute receive 429 from Edge middleware"
    - "Clerk auth callback routes are exempt from IP rate limiting"
  artifacts:
    - path: "apps/web/components/graph/ExportFAB.tsx"
      provides: "Floating action buttons for JSON and PNG export"
      min_lines: 40
    - path: "apps/web/proxy.ts"
      provides: "IP rate limiting via @upstash/ratelimit composed with Clerk auth"
      contains: "ratelimit"
  key_links:
    - from: "apps/web/app/app/page.tsx"
      to: "apps/web/components/graph/ExportFAB.tsx"
      via: "Rendered inside success state with graph and cyRef props"
      pattern: "ExportFAB"
    - from: "apps/web/components/graph/ExportFAB.tsx"
      to: "Cytoscape cy.png()"
      via: "cyRef.current.png() for PNG export"
      pattern: "cy\\.png"
    - from: "apps/web/proxy.ts"
      to: "@upstash/ratelimit"
      via: "Ratelimit.slidingWindow(60, '60 s') keyed by IP"
      pattern: "slidingWindow"
---

<objective>
Graph export buttons (JSON + PNG) and Edge middleware IP rate limiting.

Purpose: Enable users to download their generated graphs as JSON data or PNG images for reports (EXP-01, EXP-02). Protect against brute-force attacks with per-IP rate limiting at the Edge layer (RATE-02).

Output: ExportFAB component with one-click download, IP rate limiting in proxy.ts.
</objective>

<execution_context>
@/Users/uzi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/uzi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-guardrails-export/04-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From apps/web/components/graph/GraphCanvas.tsx:
```typescript
interface GraphCanvasProps {
  graph: VCGraph
  selectedNodeId: string | null
  onNodeClick: (nodeId: string | null) => void
}
// cyRef = useRef<Cytoscape.Core | null>(null) — internal ref, needs to be exposed
// Existing "Fit" button at bottom-right: className="absolute bottom-4 right-4"
```

From apps/web/app/app/page.tsx:
```typescript
type Status = 'idle' | 'loading' | 'success'
// In success state, renders GraphCanvas + DetailPanel
// GraphCanvas is dynamically imported with ssr: false
```

From packages/shared-types/src/index.ts:
```typescript
export interface VCGraph {
  nodes: GraphNode[]
  edges: GraphEdge[]
}
export interface GraphNode {
  id: string; label: string; type: EntityType; properties: Record<string, unknown>
}
export interface GraphEdge {
  source: string; target: string; relationship: RelationshipType
}
```

From apps/web/lib/analytics.ts:
```typescript
export function captureGraphExported(format: 'json' | 'png'): void  // Already exists as stub
```

From apps/web/proxy.ts:
```typescript
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'
const isPublicRoute = createRouteMatcher([...])
export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) { await auth.protect() }
})
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: ExportFAB component + GraphCanvas cyRef exposure + export utilities</name>
  <files>
    apps/web/components/graph/GraphCanvas.tsx
    apps/web/components/graph/ExportFAB.tsx
  </files>
  <action>
    **1. Expose cyRef from GraphCanvas (apps/web/components/graph/GraphCanvas.tsx):**

    Add a new optional prop to GraphCanvasProps:
    ```typescript
    interface GraphCanvasProps {
      graph: VCGraph
      selectedNodeId: string | null
      onNodeClick: (nodeId: string | null) => void
      onCyInit?: (cy: Cytoscape.Core) => void  // NEW: exposes cy instance to parent
    }
    ```

    In `handleCyInit` callback, after `cyRef.current = cy`, call `onCyInit?.(cy)`.

    Move the "Fit" button from `bottom-4 right-4` to `bottom-4 right-28` (or similar) to make room for the FAB buttons at bottom-right. Alternatively, group the Fit button into the FAB area.

    **2. Create ExportFAB component (apps/web/components/graph/ExportFAB.tsx):**

    ```typescript
    'use client'

    import { useCallback } from 'react'
    import type Cytoscape from 'cytoscape'
    import type { VCGraph } from '@graphvc/shared-types'
    import { captureGraphExported } from '@/lib/analytics'

    interface ExportFABProps {
      graph: VCGraph
      cyRef: Cytoscape.Core | null
      title?: string  // For filename generation
    }
    ```

    **Filename generation helper:**
    ```typescript
    function generateFilename(graph: VCGraph, title: string | undefined, ext: string): string {
      // Use title if available, otherwise first 3-4 node labels slugified
      const slug = title
        ? title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '').slice(0, 40)
        : graph.nodes.slice(0, 4).map(n => n.label).join('-').toLowerCase().replace(/[^a-z0-9]+/g, '-').slice(0, 40)
      const date = new Date().toISOString().slice(0, 10)  // YYYY-MM-DD
      return `graphvc-${slug}-${date}.${ext}`
    }
    ```

    **Export JSON handler (EXP-01):**
    - Create cleaned/simplified format per CONTEXT.md locked decision:
      ```typescript
      const simplified = {
        nodes: graph.nodes.map(n => ({ id: n.id, label: n.label, type: n.type, ...n.properties })),
        edges: graph.edges.map(e => ({ from: e.source, to: e.target, relationship: e.relationship })),
        exported_at: new Date().toISOString(),
      }
      ```
    - Create Blob with `application/json` type, `URL.createObjectURL()`, programmatic `<a>` click, then `URL.revokeObjectURL()`.
    - Call `captureGraphExported('json')` after download triggers.

    **Export PNG handler (EXP-02):**
    - Use Cytoscape built-in: `cy.png({ full: true, output: 'blob-promise', bg: '#030712', scale: 2, maxWidth: 4096 })` — NOT html-to-image.
    - `#030712` is the gray-950 background color matching the app (CONTEXT.md: "PNG background matches the app background").
    - `maxWidth: 4096` is a safety cap per Research pitfall #2 (large canvas null blob).
    - Same createObjectURL + programmatic `<a>` click pattern.
    - Call `captureGraphExported('png')` after download triggers.
    - Handle null blob gracefully (show toast error if cy.png returns null).

    **Render:**
    - Two FAB-style buttons positioned `absolute bottom-4 right-4` (CONTEXT.md: "bottom-right corner of the graph canvas").
    - Styling: `bg-gray-800 hover:bg-gray-700 border border-gray-600 text-gray-300 rounded-lg` — matching the existing Fit button style.
    - Stack vertically with a small gap. Use download/image icons (inline SVGs).
    - Only render when `cyRef` is not null (which means graph is rendered).
    - One-click instant download — no intermediary modal or popover (CONTEXT.md locked decision).
  </action>
  <verify>
    <automated>cd apps/web && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - GraphCanvas exposes onCyInit prop for parent to receive cy instance
    - ExportFAB renders two FAB buttons (JSON + PNG) at bottom-right of canvas
    - JSON export produces cleaned/simplified format with auto-generated filename
    - PNG export uses cy.png({full: true, bg: '#030712', scale: 2, maxWidth: 4096})
    - captureGraphExported fires on each export
    - Buttons hidden when no graph exists
    - No html-to-image dependency — uses Cytoscape built-in
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ExportFAB in AppPage + captureGraphExported analytics</name>
  <files>
    apps/web/app/app/page.tsx
  </files>
  <action>
    **1. Add cy state to AppPage (apps/web/app/app/page.tsx):**

    In `AppPageInner`, add a new ref to hold the Cytoscape instance:
    ```typescript
    const [cyInstance, setCyInstance] = useState<any>(null)
    ```

    Import ExportFAB:
    ```typescript
    import ExportFAB from '@/components/graph/ExportFAB'
    ```

    **2. Pass onCyInit to GraphCanvas:**
    ```tsx
    <GraphCanvas
      graph={graph}
      selectedNodeId={selectedNodeId}
      onNodeClick={handleNodeClick}
      onCyInit={setCyInstance}
    />
    ```

    **3. Render ExportFAB in success state:**
    Inside the success block (`status === 'success' && graph`), add ExportFAB as a sibling to the GraphCanvas wrapper div, inside the fragment:
    ```tsx
    {status === 'success' && graph && (
      <>
        <div className="flex-1 relative overflow-hidden">
          <GraphCanvas
            graph={graph}
            selectedNodeId={selectedNodeId}
            onNodeClick={handleNodeClick}
            onCyInit={setCyInstance}
          />
          <ExportFAB graph={graph} cyRef={cyInstance} />
        </div>
        {selectedNodeId && (
          <DetailPanel ... />
        )}
      </>
    )}
    ```

    Place `<ExportFAB>` inside the same relative container as GraphCanvas so its absolute positioning works correctly within the canvas area.

    **4. Clear cy instance on reset:**
    In `handleExpand` (which resets to idle), add `setCyInstance(null)`.
  </action>
  <verify>
    <automated>cd apps/web && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - AppPage holds cyInstance state, passed to ExportFAB
    - ExportFAB rendered inside graph canvas container in success state
    - cyInstance cleared on graph reset
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Edge middleware IP rate limiting in proxy.ts (RATE-02)</name>
  <files>
    apps/web/proxy.ts
    apps/web/package.json
  </files>
  <action>
    **1. Install Upstash JS SDKs:**
    From monorepo root: `pnpm --filter web add @upstash/ratelimit @upstash/redis`

    **2. Update proxy.ts to add IP rate limiting:**

    Add imports:
    ```typescript
    import { Ratelimit } from '@upstash/ratelimit'
    import { Redis } from '@upstash/redis'
    ```

    Create rate limiter instance (module-level, outside the middleware function):
    ```typescript
    // RATE-02: Per-IP brute-force protection (60 req/min sliding window)
    // Only initialized if Upstash env vars are set — graceful degradation in dev
    const ratelimit = process.env.UPSTASH_REDIS_REST_URL
      ? new Ratelimit({
          redis: Redis.fromEnv(),
          limiter: Ratelimit.slidingWindow(60, '60 s'),
          prefix: 'ratelimit:ip',
          ephemeralCache: new Map(),
        })
      : null
    ```

    Create route matcher for rate limit exemptions (Pitfall #6 from Research):
    ```typescript
    const isRateLimitExempt = createRouteMatcher([
      '/sign-in(.*)',
      '/sign-up(.*)',
      '/api/webhooks/(.*)',
    ])
    ```

    Inside `clerkMiddleware` callback, BEFORE the auth protect logic:
    ```typescript
    // RATE-02: IP rate limit (skip for auth callbacks to prevent Clerk SSO 429s)
    if (ratelimit && !isRateLimitExempt(req)) {
      const ip = req.headers.get('x-forwarded-for')?.split(',')[0] ?? '127.0.0.1'
      const { success, reset } = await ratelimit.limit(ip)
      if (!success) {
        return new Response(
          JSON.stringify({ error: 'rate_limited', message: 'Too many requests' }),
          {
            status: 429,
            headers: {
              'Content-Type': 'application/json',
              'Retry-After': String(Math.ceil((reset - Date.now()) / 1000)),
            },
          }
        )
      }
    }
    ```

    IMPORTANT: The rate limit check comes BEFORE `auth.protect()` — it must block abusive IPs before any Clerk overhead.

    **3. Env vars needed:**
    The `@upstash/redis` `Redis.fromEnv()` reads `UPSTASH_REDIS_REST_URL` and `UPSTASH_REDIS_REST_TOKEN` from environment. These are the same vars used by the backend (apps/api). Both frontend Edge and backend share the same Upstash Redis instance.

    Ensure `.env.local.example` or similar docs mention these vars. The executor should NOT create the actual .env file with secrets — just ensure the code reads from the right env vars.
  </action>
  <verify>
    <automated>cd apps/web && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - @upstash/ratelimit and @upstash/redis installed in apps/web
    - proxy.ts has SlidingWindow(60, '60 s') IP rate limiting
    - Clerk callback routes (/sign-in, /sign-up, /api/webhooks) are exempt
    - Rate limiter is null when Upstash env vars absent (graceful dev degradation)
    - 429 response includes Retry-After header and JSON body
    - Rate limit check runs before auth.protect()
  </done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` — zero TypeScript errors
2. `pnpm turbo typecheck` — monorepo-wide typecheck passes
3. ExportFAB buttons visible in success state, hidden in idle/loading states
4. proxy.ts has ratelimit import and SlidingWindow configuration
5. Clerk callback routes listed in isRateLimitExempt matcher
</verification>

<success_criteria>
- Export JSON downloads cleaned JSON with auto-generated filename
- Export PNG downloads full-graph PNG with gray-950 background via cy.png()
- FAB buttons at bottom-right, one-click download, no modal
- captureGraphExported analytics fires on each export
- Edge middleware blocks IPs exceeding 60 req/min with 429
- Clerk auth callbacks exempt from IP rate limiting
- All TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/04-guardrails-export/04-02-SUMMARY.md`
</output>
