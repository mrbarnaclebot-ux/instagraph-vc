---
phase: 01-backend-foundation
plan: 04
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - apps/api/app/auth/clerk.py
  - apps/api/app/dependencies.py
autonomous: true
requirements:
  - SEC-03

user_setup:
  - service: clerk
    why: "JWT authentication — every protected endpoint validates Clerk Bearer tokens"
    env_vars:
      - name: CLERK_SECRET_KEY
        source: "Clerk Dashboard -> Configure -> API Keys -> Secret keys"
      - name: CLERK_AUTHORIZED_PARTY
        source: "The origin URL of your frontend (e.g., http://localhost:3000 for local dev, https://your-app.vercel.app for production)"
      - name: CLERK_FRONTEND_API
        source: "Clerk Dashboard -> Configure -> API Keys -> Frontend API (format: your-instance.clerk.accounts.dev)"

must_haves:
  truths:
    - "A request with a valid unexpired Clerk JWT in Authorization: Bearer header is accepted"
    - "A request with an invalid JWT is rejected with 401 before any business logic runs"
    - "A request with an expired JWT is rejected with 401 with error='unauthorized'"
    - "A JWT with an azp claim not in CLERK_AUTHORIZED_PARTY is rejected with 401"
    - "get_current_user is registered as a dependency in dependencies.py for use in protected routes"
  artifacts:
    - path: "apps/api/app/auth/clerk.py"
      provides: "Clerk JWT verification via PyJWT + PyJWKClient"
      contains: "PyJWKClient"
    - path: "apps/api/app/dependencies.py"
      provides: "get_current_user FastAPI dependency"
      contains: "get_current_user"
  key_links:
    - from: "apps/api/app/auth/clerk.py"
      to: "Clerk JWKS endpoint"
      via: "PyJWKClient fetching from CLERK_FRONTEND_API/.well-known/jwks.json"
      pattern: "PyJWKClient"
    - from: "apps/api/app/dependencies.py"
      to: "apps/api/app/auth/clerk.py"
      via: "import and re-export of get_current_user"
      pattern: "from app.auth.clerk import get_current_user"
---

<objective>
Implement Clerk JWT verification as a FastAPI dependency using the manual PyJWT + PyJWKClient approach. Wire `get_current_user` into `dependencies.py` so protected routes can use `Depends(get_current_user)`.

Purpose: SEC-03 requires every protected endpoint to validate the Clerk JWT before executing any business logic. This plan delivers that guard. The generate endpoint (Plan 05) will use `Depends(get_current_user)` to enforce it.

Output: `apps/api/app/auth/clerk.py` with a robust `get_current_user` dependency that verifies RS256 signature, expiry, and `azp` claim via Clerk's JWKS endpoint. Updated `dependencies.py` re-exports it for clean import by routers.
</objective>

<execution_context>
@/Users/uzi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/uzi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-backend-foundation/01-CONTEXT.md
@.planning/phases/01-backend-foundation/01-RESEARCH.md
@.planning/phases/01-backend-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Clerk JWT dependency with PyJWT fallback pattern</name>
  <files>
    apps/api/app/auth/clerk.py
  </files>
  <action>
Implement `apps/api/app/auth/clerk.py` using the manual PyJWT + PyJWKClient approach.

**Why manual PyJWT instead of clerk-backend-api SDK:**
STATE.md documents this concern: "fastapi-clerk-auth is v0.0.9, low-activity library — have manual PyJWT + PyJWKClient fallback pattern ready." The RESEARCH.md also documents Pitfall 5: `clerk-backend-api.authenticate_request()` expects `httpx.Request` objects but FastAPI provides `starlette.requests.Request`. The manual PyJWT approach has zero third-party coupling beyond PyJWT (already a project dependency), gives full control over the `azp` claim validation that SEC-03 requires, and is fully documented.

**Implementation:**

```python
import os
from fastapi import Depends, HTTPException
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
import jwt
from jwt import PyJWKClient

from app.config import settings

# JWKS client — fetches and caches Clerk's public keys
# Initialized once at module import (lazy singleton pattern)
# PyJWKClient handles key rotation automatically — re-fetches when JWT kid is unknown
_jwks_client: PyJWKClient | None = None


def _get_jwks_client() -> PyJWKClient:
    """Returns the singleton PyJWKClient, creating it on first call."""
    global _jwks_client
    if _jwks_client is None:
        jwks_url = f"https://{settings.clerk_frontend_api}/.well-known/jwks.json"
        _jwks_client = PyJWKClient(jwks_url, cache_keys=True)
    return _jwks_client


_bearer = HTTPBearer(auto_error=False)


async def get_current_user(
    credentials: HTTPAuthorizationCredentials | None = Depends(_bearer),
) -> dict:
    """
    FastAPI dependency — validates Clerk JWT Bearer token (SEC-03).

    Validates:
    1. Authorization: Bearer header is present
    2. JWT signature via RS256 using Clerk's JWKS public keys
    3. Token expiry (verify_exp=True)
    4. azp claim matches CLERK_AUTHORIZED_PARTY (prevents token misuse across apps)

    Returns the decoded JWT payload dict on success.
    Raises HTTPException(401) for any validation failure.

    Usage in a protected route:
        @router.post("/api/generate")
        async def generate(
            request: GenerateRequest,
            current_user: dict = Depends(get_current_user),
        ):
            user_id = current_user.get("sub")
    """
    if credentials is None:
        raise HTTPException(
            status_code=401,
            detail={"error": "unauthorized", "message": "Missing authorization token"},
        )

    token = credentials.credentials

    try:
        jwks_client = _get_jwks_client()
        signing_key = jwks_client.get_signing_key_from_jwt(token)

        payload = jwt.decode(
            token,
            signing_key.key,
            algorithms=["RS256"],
            options={"verify_exp": True},
        )

        # Validate azp claim (SEC-03: authorized_parties check)
        # azp = Authorized Party — the frontend origin that issued the token
        # This prevents tokens issued for one app being used against another
        azp = payload.get("azp", "")
        allowed_parties = [
            p.strip()
            for p in settings.clerk_authorized_party.split(",")
            if p.strip()
        ]
        if azp and allowed_parties and azp not in allowed_parties:
            raise jwt.InvalidClaimError("azp claim not in authorized parties")

        return payload

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=401,
            detail={"error": "unauthorized", "message": "Token expired"},
        )
    except jwt.InvalidClaimError:
        raise HTTPException(
            status_code=401,
            detail={"error": "unauthorized", "message": "Token claim validation failed"},
        )
    except jwt.DecodeError:
        raise HTTPException(
            status_code=401,
            detail={"error": "unauthorized", "message": "Invalid token"},
        )
    except Exception:
        # Catch-all: JWKS fetch failure, unexpected JWT errors
        raise HTTPException(
            status_code=401,
            detail={"error": "unauthorized", "message": "Token verification failed"},
        )
```

**Important implementation notes:**
- `HTTPBearer(auto_error=False)` — returns `None` instead of raising 422 when header is missing. The explicit `None` check produces our standard `{"error": "unauthorized", "message": "..."}` shape rather than FastAPI's default validation error.
- `cache_keys=True` on PyJWKClient — caches Clerk's public keys. Clerk rotates keys, but PyJWKClient re-fetches when a JWT's `kid` header does not match any cached key.
- The catch-all `except Exception` is intentional — JWKS network failures (Clerk is down) should return 401, not 500.
- `settings.clerk_authorized_party` supports comma-separated values for multiple environments: `http://localhost:3000,https://app.graphvc.com`
  </action>
  <verify>
    <automated>cd "/Users/uzi/Documents/Git Projects/instagraph-vc/apps/api" && uv run python -c "from app.auth.clerk import get_current_user; print('Clerk auth module imports OK')"</automated>
    <manual>Confirm `clerk.py` uses `PyJWKClient` (not `clerk-backend-api`). Confirm `azp` claim validation is present. Confirm all HTTP 401 responses use `{"error": "unauthorized", "message": "..."}` shape.</manual>
  </verify>
  <done>
    - `apps/api/app/auth/clerk.py` imports successfully
    - `get_current_user` is an async FastAPI dependency using `Depends(HTTPBearer())`
    - JWT verification uses RS256 via `PyJWKClient` fetching from `CLERK_FRONTEND_API/.well-known/jwks.json`
    - `azp` claim validated against `CLERK_AUTHORIZED_PARTY`
    - All 401 responses use standard `{"error": "unauthorized", "message": "..."}` error shape
    - Missing token returns 401 (not 422 validation error)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire get_current_user into dependencies.py</name>
  <files>
    apps/api/app/dependencies.py
  </files>
  <action>
Update `apps/api/app/dependencies.py` (created in Plan 01 with just `get_neo4j_driver`) to also re-export `get_current_user`. This gives routers a single import point for all shared dependencies.

**Updated `apps/api/app/dependencies.py`:**

```python
from fastapi import Request
from neo4j import Driver

from app.auth.clerk import get_current_user  # noqa: F401 — re-exported for routers


def get_neo4j_driver(request: Request) -> Driver:
    """
    Returns the singleton Neo4j driver from app.state (SEC-04).
    The driver is created once in the lifespan context manager in main.py
    and stored in app.state.neo4j_driver. Never instantiate a new driver
    inside a route handler or dependency.
    """
    return request.app.state.neo4j_driver


# Usage in protected routes:
#
#   from app.dependencies import get_neo4j_driver, get_current_user
#
#   @router.post("/api/generate")
#   async def generate(
#       body: GenerateRequest,
#       driver: Driver = Depends(get_neo4j_driver),
#       current_user: dict = Depends(get_current_user),
#   ):
#       user_id = current_user.get("sub")
```

The `# noqa: F401` suppresses the "imported but unused" lint warning since `get_current_user` is imported here to be re-exported, not used directly.

After writing, verify the import chain works end-to-end:
```bash
cd apps/api && uv run python -c "
from app.dependencies import get_neo4j_driver, get_current_user
print('get_neo4j_driver:', get_neo4j_driver)
print('get_current_user:', get_current_user)
print('Dependency imports OK')
"
```
  </action>
  <verify>
    <automated>cd "/Users/uzi/Documents/Git Projects/instagraph-vc/apps/api" && uv run python -c "from app.dependencies import get_neo4j_driver, get_current_user; print('OK')"</automated>
    <manual>Confirm both `get_neo4j_driver` and `get_current_user` are importable from `app.dependencies`. Confirm the usage comment in dependencies.py shows the correct pattern for protected routes.</manual>
  </verify>
  <done>
    - `from app.dependencies import get_neo4j_driver, get_current_user` succeeds
    - `get_current_user` is the function from `app.auth.clerk` (not a stub)
    - `dependencies.py` includes usage comment showing how to use both deps in a route
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cd apps/api && uv run python -c "from app.dependencies import get_neo4j_driver, get_current_user; print('OK')"` prints OK
2. `grep "PyJWKClient" apps/api/app/auth/clerk.py` — returns match
3. `grep "azp" apps/api/app/auth/clerk.py` — returns match (azp claim validation present)
4. `grep "auto_error=False" apps/api/app/auth/clerk.py` — returns match (missing token → 401, not 422)
5. All error responses in `clerk.py` use `{"error": "unauthorized", "message": "..."}` shape
</verification>

<success_criteria>
- `get_current_user` FastAPI dependency validates Clerk JWT via RS256 and JWKS
- Missing Authorization header → 401 with `{"error": "unauthorized", ...}`
- Expired token → 401
- Invalid signature → 401
- Valid token with non-matching `azp` → 401
- Both dependencies (`get_neo4j_driver`, `get_current_user`) importable from `app.dependencies`
- No dependency on `fastapi-clerk-auth` or `clerk-backend-api` packages (per PyJWT fallback decision)
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-04-SUMMARY.md`
</output>
