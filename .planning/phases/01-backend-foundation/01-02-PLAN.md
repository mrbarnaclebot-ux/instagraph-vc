---
phase: 01-backend-foundation
plan: 02
type: tdd
wave: 2
depends_on:
  - "01-01"
files_modified:
  - apps/api/app/scraper/ssrf.py
  - apps/api/tests/test_ssrf.py
autonomous: true
requirements:
  - SEC-01
  - AI-04

must_haves:
  truths:
    - "A URL pointing to 127.0.0.1 or 10.0.0.1 is rejected with HTTPException(400)"
    - "A URL using http:// (not https) is rejected with HTTPException(400)"
    - "A valid public HTTPS URL passes validation without raising"
    - "Input shorter than 200 characters raises HTTPException(400) with the exact message from AI-04"
    - "All SSRF test cases are covered by automated pytest tests that run in under 10 seconds"
  artifacts:
    - path: "apps/api/app/scraper/ssrf.py"
      provides: "SSRF URL validator — validate_url() function"
      contains: "BLOCKED_NETWORKS"
    - path: "apps/api/tests/test_ssrf.py"
      provides: "Pytest test suite for SSRF validation and input length"
      contains: "test_rejects_private_ip"
  key_links:
    - from: "apps/api/tests/test_ssrf.py"
      to: "apps/api/app/scraper/ssrf.py"
      via: "direct function import"
      pattern: "from app.scraper.ssrf import validate_url"
---

<objective>
Build the SSRF URL validator using TDD. Write failing tests first, then implement `validate_url()` in `ssrf.py` to make them pass. Also cover the AI-04 input length requirement with a parametrized test against the Pydantic `GenerateRequest` schema (created in Plan 05) or as a standalone validator.

Purpose: SSRF is the most critical security requirement in this phase. TDD ensures the validator is verifiably correct against a checklist of attack vectors — not just "looks right." The RED-GREEN cycle proves each blocked case was genuinely failing before the fix.

Output: `apps/api/app/scraper/ssrf.py` with `validate_url()` and `validate_input_length()`, backed by a comprehensive pytest suite in `tests/test_ssrf.py`.
</objective>

<execution_context>
@/Users/uzi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/uzi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-backend-foundation/01-CONTEXT.md
@.planning/phases/01-backend-foundation/01-RESEARCH.md
@.planning/phases/01-backend-foundation/01-01-SUMMARY.md
</context>

<feature>
  <name>SSRF URL Validator and Input Length Validator</name>
  <files>apps/api/app/scraper/ssrf.py, apps/api/tests/test_ssrf.py</files>

  <behavior>
**validate_url(url: str) -> str**
Must enforce ALL of these — each case must have a test:

REJECT (HTTPException 400) cases:
- `http://127.0.0.1/secret` — loopback IP
- `https://127.0.0.1/secret` — loopback over HTTPS still blocked
- `https://10.0.0.1/admin` — RFC 1918 private range
- `https://10.255.255.255/` — RFC 1918 private range upper bound
- `https://172.16.0.1/` — RFC 1918 private range (172.16.0.0/12)
- `https://192.168.1.1/` — RFC 1918 private range
- `https://169.254.169.254/latest/meta-data/` — AWS metadata endpoint (link-local)
- `http://example.com/path` — HTTP scheme (not HTTPS)
- `ftp://example.com/file` — non-HTTP scheme
- `https://` (empty hostname) — malformed URL

PASS (return url unchanged) cases:
- `https://techcrunch.com/2024/funding-announcement` — valid public URL
- `https://coindesk.com/article` — valid public URL

Note on DNS resolution: The validator calls `socket.gethostbyname()`. In tests, mock this to return controlled IPs. Do NOT make real DNS lookups in tests.

**validate_input_length(text: str) -> str**
REJECT (HTTPException 400) cases:
- Any string with `len(text) < 200` must raise with message exactly:
  `"Input too short — paste a full funding announcement or article for best results"`

PASS cases:
- Any string with `len(text) >= 200`

Cases: input -> expected output
- `"short text"` -> `HTTPException(status_code=400)` with exact message
- `"a" * 199` -> `HTTPException(status_code=400)` with exact message
- `"a" * 200` -> `"a" * 200` (exact string returned)
- `"a" * 500` -> `"a" * 500` (exact string returned)
  </behavior>

  <implementation>
**RED phase — write tests/test_ssrf.py first:**

```python
import pytest
from unittest.mock import patch
from fastapi import HTTPException
from app.scraper.ssrf import validate_url, validate_input_length

class TestValidateUrl:
    def test_rejects_http_scheme(self):
        with pytest.raises(HTTPException) as exc_info:
            validate_url("http://example.com/path")
        assert exc_info.value.status_code == 400

    def test_rejects_ftp_scheme(self):
        with pytest.raises(HTTPException) as exc_info:
            validate_url("ftp://example.com/file")
        assert exc_info.value.status_code == 400

    def test_rejects_empty_hostname(self):
        with pytest.raises(HTTPException) as exc_info:
            validate_url("https://")
        assert exc_info.value.status_code == 400

    @patch("app.scraper.ssrf.socket.gethostbyname", return_value="127.0.0.1")
    def test_rejects_loopback_ip(self, mock_dns):
        with pytest.raises(HTTPException) as exc_info:
            validate_url("https://evil.com/path")
        assert exc_info.value.status_code == 400

    @patch("app.scraper.ssrf.socket.gethostbyname", return_value="10.0.0.1")
    def test_rejects_rfc1918_10_block(self, mock_dns):
        with pytest.raises(HTTPException) as exc_info:
            validate_url("https://evil.com/path")
        assert exc_info.value.status_code == 400

    @patch("app.scraper.ssrf.socket.gethostbyname", return_value="10.255.255.255")
    def test_rejects_rfc1918_10_block_upper(self, mock_dns):
        with pytest.raises(HTTPException) as exc_info:
            validate_url("https://evil.com/path")
        assert exc_info.value.status_code == 400

    @patch("app.scraper.ssrf.socket.gethostbyname", return_value="172.16.0.1")
    def test_rejects_rfc1918_172_block(self, mock_dns):
        with pytest.raises(HTTPException) as exc_info:
            validate_url("https://evil.com/path")
        assert exc_info.value.status_code == 400

    @patch("app.scraper.ssrf.socket.gethostbyname", return_value="192.168.1.1")
    def test_rejects_rfc1918_192_block(self, mock_dns):
        with pytest.raises(HTTPException) as exc_info:
            validate_url("https://evil.com/path")
        assert exc_info.value.status_code == 400

    @patch("app.scraper.ssrf.socket.gethostbyname", return_value="169.254.169.254")
    def test_rejects_aws_metadata_endpoint(self, mock_dns):
        with pytest.raises(HTTPException) as exc_info:
            validate_url("https://evil.com/path")
        assert exc_info.value.status_code == 400

    @patch("app.scraper.ssrf.socket.gethostbyname", return_value="93.184.216.34")
    def test_accepts_valid_public_url(self, mock_dns):
        result = validate_url("https://example.com/article")
        assert result == "https://example.com/article"

    @patch("app.scraper.ssrf.socket.gethostbyname", return_value="104.18.20.100")
    def test_accepts_techcrunch_url(self, mock_dns):
        result = validate_url("https://techcrunch.com/2024/01/01/funding")
        assert result == "https://techcrunch.com/2024/01/01/funding"


class TestValidateInputLength:
    def test_rejects_short_text(self):
        with pytest.raises(HTTPException) as exc_info:
            validate_input_length("short text")
        assert exc_info.value.status_code == 400
        assert exc_info.value.detail["error"] == "input_too_short"
        assert "Input too short" in exc_info.value.detail["message"]
        assert "paste a full funding announcement" in exc_info.value.detail["message"]

    def test_rejects_199_chars(self):
        with pytest.raises(HTTPException) as exc_info:
            validate_input_length("a" * 199)
        assert exc_info.value.status_code == 400

    def test_accepts_200_chars(self):
        result = validate_input_length("a" * 200)
        assert result == "a" * 200

    def test_accepts_long_text(self):
        long_text = "a" * 1000
        result = validate_input_length(long_text)
        assert result == long_text

    def test_exact_error_message(self):
        with pytest.raises(HTTPException) as exc_info:
            validate_input_length("too short")
        expected = "Input too short — paste a full funding announcement or article for best results"
        assert exc_info.value.detail["message"] == expected
```

Run the tests — all must FAIL (RED). Commit: `test(01-02): add failing tests for SSRF validator and input length`

**GREEN phase — implement apps/api/app/scraper/ssrf.py:**

Implement `validate_url()` using the `ipaddress` stdlib module (do NOT hand-roll IP range checks with regex):

```python
import ipaddress
import socket
from urllib.parse import urlparse
from fastapi import HTTPException

BLOCKED_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
    ipaddress.ip_network("169.254.0.0/16"),   # link-local / AWS metadata endpoint
    ipaddress.ip_network("::1/128"),           # IPv6 loopback
    ipaddress.ip_network("fc00::/7"),          # IPv6 ULA (unique local)
    ipaddress.ip_network("100.64.0.0/10"),     # Shared address space (RFC 6598)
]

def validate_url(url: str) -> str:
    """
    Validates a URL against SSRF attack vectors (SEC-01).
    Returns url unchanged if valid, raises HTTPException(400) otherwise.

    DNS rebinding protection: hostname is resolved once here.
    The caller (scraper.py) must use allow_redirects=False and
    re-validate any redirect targets through this function.
    """
    parsed = urlparse(url)

    if parsed.scheme != "https":
        raise HTTPException(status_code=400, detail={
            "error": "invalid_url",
            "message": "Only HTTPS URLs are accepted",
        })

    hostname = parsed.hostname
    if not hostname:
        raise HTTPException(status_code=400, detail={
            "error": "invalid_url",
            "message": "Could not parse hostname from URL",
        })

    try:
        resolved_ip = socket.gethostbyname(hostname)
    except socket.gaierror:
        raise HTTPException(status_code=400, detail={
            "error": "invalid_url",
            "message": "Could not resolve hostname",
        })

    try:
        ip_obj = ipaddress.ip_address(resolved_ip)
    except ValueError:
        raise HTTPException(status_code=400, detail={
            "error": "invalid_url",
            "message": "Invalid IP address resolved from hostname",
        })

    # Block private/loopback/link-local ranges
    for network in BLOCKED_NETWORKS:
        if ip_obj in network:
            raise HTTPException(status_code=400, detail={
                "error": "invalid_url",
                "message": "URL resolves to a blocked address",
            })

    # Catch-all: block non-global addresses not covered by explicit ranges
    if not ip_obj.is_global:
        raise HTTPException(status_code=400, detail={
            "error": "invalid_url",
            "message": "URL resolves to a non-public address",
        })

    return url


def validate_input_length(text: str) -> str:
    """
    Rejects inputs shorter than 200 characters (AI-04).
    Returns text unchanged if valid, raises HTTPException(400) otherwise.
    """
    if len(text) < 200:
        raise HTTPException(status_code=400, detail={
            "error": "input_too_short",
            "message": "Input too short — paste a full funding announcement or article for best results",
        })
    return text
```

Run the tests — all must PASS (GREEN). Commit: `feat(01-02): implement SSRF validator and input length validator`

**REFACTOR phase (if needed):**
Review for clarity — the implementation above is already clean. If any test is redundant, remove it. Run tests again to confirm still GREEN. Commit if changed: `refactor(01-02): clean up SSRF validator`
  </implementation>
</feature>

<verification>
```bash
cd "/Users/uzi/Documents/Git Projects/instagraph-vc/apps/api" && uv run pytest tests/test_ssrf.py -v
```
All tests pass. Output shows GREEN for all test cases including:
- `test_rejects_loopback_ip` PASSED
- `test_rejects_aws_metadata_endpoint` PASSED
- `test_rejects_http_scheme` PASSED
- `test_accepts_valid_public_url` PASSED
- `test_exact_error_message` PASSED
</verification>

<success_criteria>
- `pytest tests/test_ssrf.py` passes with 0 failures and 0 errors
- `validate_url("https://127.0.0.1/")` raises `HTTPException(400)`
- `validate_url("https://10.0.0.1/")` raises `HTTPException(400)`
- `validate_url("http://example.com/")` raises `HTTPException(400)` (HTTP not HTTPS)
- `validate_url("https://techcrunch.com/...")` returns the URL unchanged (mocked DNS = public IP)
- `validate_input_length("a" * 199)` raises `HTTPException(400)` with exact message from AI-04
- `validate_input_length("a" * 200)` returns the string unchanged
- Error detail shape is `{"error": str, "message": str}` matching the API contract from CONTEXT.md
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-02-SUMMARY.md`
</output>
