---
phase: 01-backend-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/pyproject.toml
  - apps/api/.python-version
  - apps/api/.env.example
  - apps/api/Dockerfile
  - apps/api/app/__init__.py
  - apps/api/app/main.py
  - apps/api/app/config.py
  - apps/api/app/dependencies.py
  - docker-compose.yml
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - SEC-04

must_haves:
  truths:
    - "Developer runs `docker-compose up` and Neo4j and Redis containers start healthy"
    - "FastAPI app starts and `/health` returns 200 with `{status: ok}`"
    - "Neo4j driver is created once at startup and stored in app.state — not per request"
    - "Settings load from .env file via Pydantic BaseSettings — missing required vars raise an error at startup"
    - "Dockerfile builds successfully with uv as the package manager"
  artifacts:
    - path: "apps/api/pyproject.toml"
      provides: "uv-managed dependency manifest"
      contains: "fastapi"
    - path: "apps/api/app/main.py"
      provides: "FastAPI app with lifespan context manager"
      contains: "asynccontextmanager"
    - path: "apps/api/app/config.py"
      provides: "Pydantic BaseSettings for env var loading"
      contains: "BaseSettings"
    - path: "docker-compose.yml"
      provides: "Neo4j + Redis + api service definitions"
      contains: "neo4j"
  key_links:
    - from: "apps/api/app/main.py"
      to: "app.state.neo4j_driver"
      via: "lifespan asynccontextmanager"
      pattern: "app\\.state\\.neo4j_driver"
    - from: "apps/api/app/dependencies.py"
      to: "app.state.neo4j_driver"
      via: "request.app.state"
      pattern: "request\\.app\\.state\\.neo4j_driver"
    - from: "docker-compose.yml"
      to: "apps/api"
      via: "depends_on neo4j service_healthy"
      pattern: "service_healthy"
---

<objective>
Scaffold the `apps/api/` FastAPI service from scratch using uv, establish the Neo4j driver singleton via the lifespan context manager, and wire up the docker-compose environment with Neo4j and Redis services.

Purpose: Every subsequent plan in this phase depends on the app skeleton, config system, and dev environment being in place. This is the foundation everything else is built on.

Output: A running FastAPI service at `apps/api/` with the correct directory structure, uv-managed dependencies, Pydantic settings, Neo4j lifespan singleton, and a docker-compose.yml that starts Neo4j + Redis with healthchecks.
</objective>

<execution_context>
@/Users/uzi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/uzi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation/01-CONTEXT.md
@.planning/phases/01-backend-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold apps/api/ with uv and FastAPI skeleton</name>
  <files>
    apps/api/pyproject.toml
    apps/api/.python-version
    apps/api/.env.example
    apps/api/Dockerfile
    apps/api/app/__init__.py
    apps/api/app/main.py
    apps/api/app/config.py
    apps/api/app/dependencies.py
  </files>
  <action>
Create the `apps/api/` directory structure for the FastAPI service. Use uv as the package manager (per Claude's Discretion — uv is 10-100x faster than pip, endorsed by official FastAPI docs, pyproject.toml-native).

**Step 1 — Initialize with uv:**
```bash
cd apps/api
uv init --app --python 3.12
```
This creates `pyproject.toml` and `.python-version`. Then add all dependencies:
```bash
uv add "fastapi[standard]>=0.115" "openai>=1.40,<2" "neo4j==5.28.3" requests beautifulsoup4 lxml PyJWT cryptography python-dotenv pydantic-settings
uv add --dev pytest pytest-asyncio httpx
```
CRITICAL: Pin `neo4j==5.28.3` — v6 has breaking changes (changed error hierarchy, explicit `.close()` required, dropped Python 3.9). STATE.md documents this decision.

**Step 2 — Create directory structure:**
```
apps/api/
├── app/
│   ├── __init__.py          (empty)
│   ├── main.py              (FastAPI app + lifespan)
│   ├── config.py            (Pydantic BaseSettings)
│   ├── dependencies.py      (get_neo4j_driver, placeholder for get_current_user)
│   ├── generate/            (empty __init__.py — populated in Plan 05)
│   ├── scraper/             (empty __init__.py — populated in Plan 03)
│   ├── graph/               (empty __init__.py — populated in Plan 03)
│   └── auth/                (empty __init__.py — populated in Plan 04)
└── tests/
    ├── __init__.py           (empty)
    └── conftest.py           (empty for now — test fixtures added in Plans 02+)
```

**Step 3 — Write `apps/api/app/config.py`:**
Use `pydantic-settings` (separate package from pydantic v2):
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    openai_api_key: str
    neo4j_uri: str = "bolt://localhost:7687"
    neo4j_username: str = "neo4j"
    neo4j_password: str
    clerk_secret_key: str
    clerk_authorized_party: str
    clerk_frontend_api: str

    model_config = {"env_file": ".env"}

settings = Settings()
```

**Step 4 — Write `apps/api/app/main.py`:**
Use the lifespan context manager pattern (NOT deprecated `@app.on_event`):
```python
from contextlib import asynccontextmanager
from fastapi import FastAPI
from neo4j import GraphDatabase
from app.config import settings

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup — create driver singleton (SEC-04)
    app.state.neo4j_driver = GraphDatabase.driver(
        settings.neo4j_uri,
        auth=(settings.neo4j_username, settings.neo4j_password),
    )
    app.state.neo4j_driver.verify_connectivity()
    # Create session_id index on startup (idempotent)
    with app.state.neo4j_driver.session() as session:
        session.run(
            "CREATE INDEX entity_session_id IF NOT EXISTS "
            "FOR (n:Entity) ON (n.session_id)"
        )
    yield
    # Shutdown — always close in neo4j 5.x (mandatory in 6.x)
    app.state.neo4j_driver.close()

app = FastAPI(
    title="GraphVC API",
    version="0.1.0",
    lifespan=lifespan,
)

@app.get("/health")
async def health():
    return {"status": "ok"}
```
NOTE: Do NOT use `@app.on_event("startup")` / `@app.on_event("shutdown")` — deprecated since FastAPI 0.95.

**Step 5 — Write `apps/api/app/dependencies.py`:**
```python
from fastapi import Request
from neo4j import Driver

def get_neo4j_driver(request: Request) -> Driver:
    """Returns the singleton Neo4j driver from app.state (SEC-04)."""
    return request.app.state.neo4j_driver
```
Leave `get_current_user` as a placeholder comment — implemented in Plan 04.

**Step 6 — Write `apps/api/.env.example`:**
```
OPENAI_API_KEY=sk-...
NEO4J_URI=bolt://localhost:7687
NEO4J_USERNAME=neo4j
NEO4J_PASSWORD=localpassword
CLERK_SECRET_KEY=sk_test_...
CLERK_AUTHORIZED_PARTY=http://localhost:3000
CLERK_FRONTEND_API=your-clerk-frontend-api.clerk.accounts.dev
```

**Step 7 — Write `apps/api/Dockerfile`:**
```dockerfile
FROM python:3.12-slim

# Install uv
COPY --from=ghcr.io/astral-sh/uv:latest /uv /uvx /bin/

WORKDIR /app

# Install dependencies (leverage layer caching)
COPY pyproject.toml uv.lock ./
RUN uv sync --frozen --no-dev

# Copy application code
COPY app/ ./app/

# Run with uvicorn
CMD ["uv", "run", "uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```
</action>
  <verify>
    <automated>cd "/Users/uzi/Documents/Git Projects/instagraph-vc/apps/api" && uv run python -c "from app.main import app; print('FastAPI app imports OK')"</automated>
    <manual>Confirm `apps/api/pyproject.toml` contains `neo4j==5.28.3` and `openai>=1.40`. Confirm `app/main.py` uses `asynccontextmanager` lifespan (not deprecated `on_event`).</manual>
  </verify>
  <done>
    - `apps/api/pyproject.toml` exists with all required dependencies including `neo4j==5.28.3` and `openai>=1.40,<2`
    - `apps/api/app/main.py` uses `asynccontextmanager` lifespan that creates `app.state.neo4j_driver` and calls `.close()` on shutdown
    - `apps/api/app/config.py` uses `pydantic-settings` BaseSettings with all required env vars
    - `from app.main import app` succeeds (imports without error)
    - All subdomain directories created with `__init__.py` files
  </done>
</task>

<task type="auto">
  <name>Task 2: docker-compose.yml with Neo4j, Redis, and API service</name>
  <files>
    docker-compose.yml
  </files>
  <action>
Create `docker-compose.yml` at the repo root. This satisfies INFRA-02: `docker-compose up` starts Neo4j and Redis; the API service connects to them via env vars.

**Requirements from INFRA-02:**
- Neo4j starts and is reachable at `bolt://neo4j:7687` from within the compose network
- Redis starts and is reachable at `redis://redis:6379` from within the compose network (Redis is included now per INFRA-02, even though Phase 1 app code does not connect to it — caching lands in Phase 4)
- API service starts AFTER Neo4j is healthy
- Developer can override env vars via `apps/api/.env`

**docker-compose.yml:**
```yaml
services:
  neo4j:
    image: neo4j:5.20-community
    ports:
      - "7474:7474"   # Browser UI
      - "7687:7687"   # Bolt
    environment:
      NEO4J_AUTH: neo4j/localpassword
    volumes:
      - neo4j_data:/data
    healthcheck:
      test: ["CMD-SHELL", "cypher-shell -u neo4j -p localpassword 'RETURN 1'"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  api:
    build:
      context: ./apps/api
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    env_file:
      - ./apps/api/.env
    environment:
      NEO4J_URI: bolt://neo4j:7687
      NEO4J_USERNAME: neo4j
      NEO4J_PASSWORD: localpassword
    depends_on:
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy

volumes:
  neo4j_data:
```

**Note on `.env` for api service:** The `env_file` loads developer secrets (OPENAI_API_KEY, CLERK_SECRET_KEY, etc.). The `environment` block overrides NEO4J_URI/USERNAME/PASSWORD with the compose-network hostnames, ensuring the API uses `neo4j:7687` (the compose service name) regardless of what's in `.env`.

Do NOT commit a `.env` file — only `.env.example` is committed.
  </action>
  <verify>
    <automated>cd "/Users/uzi/Documents/Git Projects/instagraph-vc" && docker compose config --quiet 2>&1 | head -5; echo "Exit: $?"</automated>
    <manual>Run `docker compose up neo4j redis -d` and verify both containers reach healthy status with `docker compose ps`. Neo4j browser should be accessible at http://localhost:7474.</manual>
  </verify>
  <done>
    - `docker-compose.yml` exists at repo root and passes `docker compose config` validation
    - `neo4j:5.20-community` service defined with healthcheck using `cypher-shell`
    - `redis:7-alpine` service defined with `redis-cli ping` healthcheck
    - `api` service depends on both with `service_healthy` condition
    - `api` service overrides Neo4j connection to use compose service hostname
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cd apps/api && uv run python -c "from app.main import app; print(app.title)"` prints `GraphVC API`
2. `docker compose config --quiet` exits 0 (valid compose file)
3. `grep "neo4j==5.28.3" apps/api/pyproject.toml` returns a match
4. `grep "asynccontextmanager" apps/api/app/main.py` returns a match
5. `grep "app.state.neo4j_driver" apps/api/app/main.py` returns a match (lifespan wired)
6. No `@app.on_event` in `apps/api/app/main.py` (deprecated pattern absent)
</verification>

<success_criteria>
- Developer can run `cd apps/api && uv sync && uv run uvicorn app.main:app` (will fail to connect to Neo4j if not running, but imports succeed)
- `docker compose config` validates the compose file without errors
- The Neo4j singleton pattern is in place: driver created once in lifespan, stored in `app.state`, closed on shutdown
- Directory structure matches the architecture from RESEARCH.md: `app/generate/`, `app/scraper/`, `app/graph/`, `app/auth/`
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-01-SUMMARY.md`
</output>
